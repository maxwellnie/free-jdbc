package io.github.maxwellnie.free.jdbc.statement;

import io.github.maxwellnie.free.jdbc.batch.BatchSql;
import io.github.maxwellnie.free.jdbc.single.SingleSql;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.SQLException;

/**
 * @author Maxwell Nie
 */
public class PreparedIntegratedStatement extends BaseIntegratedStatement<PreparedStatement, PreparedIntegratedStatement> {
    public PreparedIntegratedStatement(Connection connection) {
        super(connection);
        super.integratedStatement = this;
    }

    @Override
    public PreparedIntegratedStatement createStatement(String sql) throws StatementException {
        this.sql = sql;
        validateConnection();
        validateSql();
        try {
            if (configuration != null)
                statement = StatementUtils.prepareStatement(connection, sql, configuration.getAutoGeneratedKeys(), configuration.getResultSetType(), configuration.getResultSetConcurrency(), configuration.getHoldability());
            else
                statement = StatementUtils.prepareStatement(connection, sql);
            applyConfiguration();
        } catch (SQLException e) {
            throw new StatementException("Prepared statement creation failed for SQL: " + sql + ", Error: " + e.getMessage() +
                    ", Expected: successful prepared statement creation, Actual: SQLException during creation", e);
        }
        return integratedStatement;
    }

    protected boolean defaultExecute() throws SqlExecutionException {
        try {
            return statement.execute();
        } catch (SQLException e) {
            throw new SqlExecutionException("Prepared statement execution failed for SQL: " + sql + ", Error: " + e.getMessage() +
                    ", Expected: successful execution, Actual: SQLException during execution", e);
        }
    }
    /**
     * Execute a single SQL statement.
     *
     * @param singleSql SQL statement to execute
     * @return number of rows affected
     * @throws SqlExecutionException if an error occurs during execution
     */
    public int executeUpdate(SingleSql singleSql) throws SqlExecutionException {
        if (singleSql == null)
            throw new SqlExecutionException("Single SQL cannot be null");
        if (statement ==  null)
            createStatement(singleSql.getSqlString());
        parameterize(SingleSql.PREPARED_STATEMENT_SINGLE_SQL_PARAMETERS_HANDLER, singleSql);
        return execute(Executor.PREPARED_STATEMENT_UPDATE_EXECUTOR);
    }
    /**
     * Execute a single SQL statement.
     *
     * @param singleSql SQL statement to execute
     * @return result set
     * @throws SqlExecutionException if an error occurs during execution
     * @throws ResultParserException if an error occurs during result parsing
     */
    public <R> R executeQuery(SingleSql singleSql, ResultParser<PreparedStatement, Boolean, R> resultParser) throws SqlExecutionException, ResultParserException {
        if (singleSql == null)
            throw new SqlExecutionException("Single SQL cannot be null");
        if (statement ==  null)
            createStatement(singleSql.getSqlString());
        parameterize(SingleSql.PREPARED_STATEMENT_SINGLE_SQL_PARAMETERS_HANDLER, singleSql);
        return execute(Executor.PREPARED_STATEMENT_EXECUTE_EXECUTOR, resultParser);
    }
    /**
     * Execute a batch SQL statement.
     *
     * @param batchSql SQL statement to execute
     * @return number of rows affected
     * @throws SqlExecutionException if an error occurs during execution
     */
    public int[] executeBatch(BatchSql batchSql) throws SqlExecutionException {
        if (batchSql == null)
            throw new SqlExecutionException("Batch SQL cannot be null");
        if (statement ==  null)
            createStatement(batchSql.getSqlString());
        parameterize(BatchSql.BATCH_SQL_PARAMETERS_HANDLER, batchSql);
        return execute(Executor.PREPARED_STATEMENT_BATCH_EXECUTOR);
    }
}